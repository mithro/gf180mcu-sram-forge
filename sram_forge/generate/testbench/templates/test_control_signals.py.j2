# SPDX-FileCopyrightText: (C) 2025 sram-forge
# SPDX-License-Identifier: Apache-2.0

"""Control signal protocol tests for {{ chip.name }}.

Generated by sram-forge - do not edit manually.

These tests verify that the control signals (CE_n, WE_n) properly gate
SRAM operations. This ensures:
- CE_n=1 blocks all read/write operations
- WE_n properly controls read vs write mode
- Signal changes while disabled have no effect
"""

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles

from sram_utils import (
    startup, create_model,
    write_sram, read_sram,
    write_sram_no_enable, read_sram_no_enable,
    build_bidir_value,
    TOTAL_WORDS, SRAM_SIZE, SRAM_COUNT, DATA_WIDTH,
)


@cocotb.test()
async def test_ce_n_disabled_blocks_write(dut):
    """Verify that writes are blocked when CE_n=1.

    Write a known value to an address, then attempt to overwrite it
    with CE_n disabled. The original value should be preserved.
    """
    await startup(dut)
    model = create_model()

    test_addr = 0x10
    original_data = 0xAA
    attempted_data = 0x55

    # Write original value (CE_n=0, should succeed)
    await write_sram(dut, test_addr, original_data)
    model.write(test_addr, original_data)
    dut._log.info(f"Wrote 0x{original_data:02X} to 0x{test_addr:04X}")

    # Verify it was written
    readback = await read_sram(dut, test_addr)
    assert readback == original_data, \
        f"Initial write failed: got 0x{readback:02X}, expected 0x{original_data:02X}"

    # Attempt to overwrite with CE_n=1 (should be blocked)
    await write_sram_no_enable(dut, test_addr, attempted_data)
    dut._log.info(f"Attempted write 0x{attempted_data:02X} with CE_n=1")

    # Read back - should still be original value
    readback = await read_sram(dut, test_addr)
    assert readback == original_data, \
        f"CE_n=1 did not block write: got 0x{readback:02X}, expected 0x{original_data:02X}"

    dut._log.info("PASS: CE_n=1 correctly blocks writes")


@cocotb.test()
async def test_ce_n_disabled_blocks_read_output(dut):
    """Verify that output is not driven when CE_n=1.

    Write different values to two addresses. Read one address, then
    attempt to read another with CE_n=1. The output should not change
    to reflect the new address.
    """
    await startup(dut)

    addr1 = 0x20
    addr2 = 0x30
    data1 = 0x11
    data2 = 0x22

    # Write two different values
    await write_sram(dut, addr1, data1)
    await write_sram(dut, addr2, data2)
    dut._log.info(f"Wrote 0x{data1:02X} to 0x{addr1:04X}, 0x{data2:02X} to 0x{addr2:04X}")

    # Read addr1 normally
    readback1 = await read_sram(dut, addr1)
    assert readback1 == data1, f"Read mismatch at addr1"
    dut._log.info(f"Read 0x{readback1:02X} from addr1")

    # Now read addr2 with CE_n=1 (disabled)
    # The SRAM should not update its output
    readback_disabled = await read_sram_no_enable(dut, addr2)
    dut._log.info(f"Read with CE_n=1: 0x{readback_disabled:02X}")

    # Note: The exact behavior depends on the SRAM macro.
    # Some SRAMs hold the last output, others may tri-state.
    # This test documents the behavior rather than asserting a specific value.

    dut._log.info("PASS: Read with CE_n=1 completed (output behavior documented)")


@cocotb.test()
async def test_we_n_toggle_while_disabled(dut):
    """Verify that WE_n changes have no effect when CE_n=1.

    With CE_n=1, toggle WE_n between read and write modes.
    No memory operations should occur.
    """
    await startup(dut)
    model = create_model()

    test_addr = 0x40
    original_data = 0xCC

    # Write initial value
    await write_sram(dut, test_addr, original_data)
    model.write(test_addr, original_data)

    # Verify
    readback = await read_sram(dut, test_addr)
    assert readback == original_data

    # Now toggle WE_n while CE_n=1

    # CE_n=1, WE_n=0 (write mode, but disabled)
    dut.bidir_PAD.value = build_bidir_value(addr=test_addr, data=0xFF, ce_n=1, we_n=0)
    await RisingEdge(dut.clk_PAD)

    # CE_n=1, WE_n=1 (read mode, but disabled)
    dut.bidir_PAD.value = build_bidir_value(addr=test_addr, data=0x00, ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Toggle back
    dut.bidir_PAD.value = build_bidir_value(addr=test_addr, data=0x55, ce_n=1, we_n=0)
    await RisingEdge(dut.clk_PAD)

    # Return to idle
    dut.bidir_PAD.value = build_bidir_value(ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Verify data unchanged
    readback = await read_sram(dut, test_addr)
    assert readback == original_data, \
        f"WE_n toggle with CE_n=1 corrupted data: got 0x{readback:02X}, expected 0x{original_data:02X}"

    dut._log.info("PASS: WE_n toggling with CE_n=1 has no effect")


@cocotb.test()
async def test_addr_change_while_disabled(dut):
    """Verify that address changes have no effect when CE_n=1.

    Write different values to multiple addresses. Then change address
    with CE_n=1 and verify no writes occur.
    """
    await startup(dut)
    model = create_model()

    # Setup: write known values to several addresses
    test_data = {
        0x00: 0x11,
        0x10: 0x22,
        0x20: 0x33,
        0x30: 0x44,
    }

    for addr, data in test_data.items():
        await write_sram(dut, addr, data)
        model.write(addr, data)

    # Now rapidly change address with CE_n=1 and WE_n=0 (write mode but disabled)

    for addr in test_data.keys():
        # Different data value that should NOT be written
        dut.bidir_PAD.value = build_bidir_value(addr=addr, data=0xFF, ce_n=1, we_n=0)
        await RisingEdge(dut.clk_PAD)

    # Return to idle
    dut.bidir_PAD.value = build_bidir_value(ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Verify all original values preserved
    errors = 0
    for addr, expected in test_data.items():
        actual = await read_sram(dut, addr)
        if actual != expected:
            dut._log.error(f"Addr 0x{addr:04X}: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1

    assert errors == 0, f"Address changes with CE_n=1 corrupted {errors} locations"
    dut._log.info("PASS: Address changes with CE_n=1 have no effect")


@cocotb.test()
async def test_simultaneous_ce_we_assertion(dut):
    """Verify proper behavior when CE_n and WE_n change simultaneously.

    Test the case where both control signals transition on the same clock edge.
    """
    await startup(dut)
    model = create_model()

    test_addr = 0x50
    data_phase1 = 0xAB
    data_phase2 = 0xCD


    # Start with CE_n=1, WE_n=1 (idle)
    dut.bidir_PAD.value = build_bidir_value(ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Simultaneously assert CE_n=0, WE_n=0 (enable + write)
    dut.bidir_PAD.value = build_bidir_value(addr=test_addr, data=data_phase1, ce_n=0, we_n=0)
    await RisingEdge(dut.clk_PAD)
    model.write(test_addr, data_phase1)

    # Simultaneously deassert both
    dut.bidir_PAD.value = build_bidir_value(ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Verify write occurred
    readback = await read_sram(dut, test_addr)
    assert readback == data_phase1, \
        f"Simultaneous assertion failed: got 0x{readback:02X}, expected 0x{data_phase1:02X}"

    # Now test CE_n=0, WE_n=1 (enable + read) to CE_n=0, WE_n=0 (write)
    # First, read the current value
    dut.bidir_PAD.value = build_bidir_value(addr=test_addr, ce_n=0, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Transition to write on same address
    dut.bidir_PAD.value = build_bidir_value(addr=test_addr, data=data_phase2, ce_n=0, we_n=0)
    await RisingEdge(dut.clk_PAD)
    model.write(test_addr, data_phase2)

    # Back to idle
    dut.bidir_PAD.value = build_bidir_value(ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Verify second write
    readback = await read_sram(dut, test_addr)
    assert readback == data_phase2, \
        f"Transition write failed: got 0x{readback:02X}, expected 0x{data_phase2:02X}"

    dut._log.info("PASS: Simultaneous CE_n/WE_n changes work correctly")


@cocotb.test()
async def test_back_to_back_operations(dut):
    """Verify back-to-back read/write operations work correctly.

    Test rapid sequences of operations without idle cycles between them.
    """
    await startup(dut)
    model = create_model()


    base_addr = 0x60
    num_ops = 16

    # Back-to-back writes
    for i in range(num_ops):
        addr = base_addr + i
        data = (i * 17) & 0xFF  # Pseudo-random pattern
        dut.bidir_PAD.value = build_bidir_value(addr=addr, data=data, ce_n=0, we_n=0)
        await RisingEdge(dut.clk_PAD)
        model.write(addr, data)

    # Back to idle
    dut.bidir_PAD.value = build_bidir_value(ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)

    # Back-to-back reads and verify
    errors = 0
    for i in range(num_ops):
        addr = base_addr + i
        expected = (i * 17) & 0xFF

        dut.bidir_PAD.value = build_bidir_value(addr=addr, ce_n=0, we_n=1)
        await RisingEdge(dut.clk_PAD)
        await RisingEdge(dut.clk_PAD)  # Wait for output

        bidir_val = int(dut.bidir_PAD.value)
        actual = bidir_val & ((1 << DATA_WIDTH) - 1)

        if actual != expected:
            dut._log.error(f"Back-to-back mismatch at 0x{addr:04X}: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1

    dut.bidir_PAD.value = build_bidir_value(ce_n=1, we_n=1)

    assert errors == 0, f"Back-to-back operations had {errors} errors"
    dut._log.info("PASS: Back-to-back operations work correctly")
