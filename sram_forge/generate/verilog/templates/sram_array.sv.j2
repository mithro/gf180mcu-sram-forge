// SPDX-FileCopyrightText: Â© 2025 SRAM Forge Contributors
// SPDX-License-Identifier: Apache-2.0
// Generated by sram-forge
// Chip: {{ chip.name }}
{% if chip.description %}// {{ chip.description }}{% endif %}

// Configuration:
//   SRAM Macro: {{ macro_name }}
//   Total SRAMs: {{ sram_count }}
//   Total Words: {{ fit.total_words }}
//   Address Bits: {{ addr_bits }}
//   Data Width: {{ data_width }}
//   Output Routing: {{ output_routing }}

`default_nettype none

module {{ chip.name }}_sram_array (
    `ifdef USE_POWER_PINS
    // Power supplies (directly connected to SRAM macros)
    inout  wire                    VDD,
    inout  wire                    VSS,
    `endif
    // Functional signals
    input  wire                    clk,
    input  wire                    rst_n,
    input  wire                    ce_n,      // Chip enable (active low)
    input  wire                    we_n,      // Write enable (active low)
    input  wire [{{ addr_bits - 1 }}:0]       addr,      // Address bus
    input  wire [{{ data_width - 1 }}:0]        din,       // Data input
    output wire [{{ data_width - 1 }}:0]        dout       // Data output
{% if write_mask %}
    ,input wire [{{ data_width - 1 }}:0]        wem_n      // Write mask (active low)
{% endif %}
);

    // Address decoding
    // Upper bits select SRAM, lower bits address within SRAM
    wire [{{ select_bits - 1 }}:0] sram_sel;
    wire [{{ sram_addr_bits - 1 }}:0] sram_addr;

    assign sram_sel = addr[{{ addr_bits - 1 }}:{{ sram_addr_bits }}];
    assign sram_addr = addr[{{ sram_addr_bits - 1 }}:0];

    // SRAM enable signals (directly from address decoder)
    wire [{{ sram_count - 1 }}:0] sram_ce_n;
{% for i in range(sram_count) %}
    assign sram_ce_n[{{ i }}] = ce_n | (sram_sel != {{ select_bits }}'d{{ i }});
{% endfor %}

    // SRAM output buses
{% for i in range(sram_count) %}
    wire [{{ data_width - 1 }}:0] sram_dout_{{ i }};
{% endfor %}

    // SRAM macro instantiations
{% for i in range(sram_count) %}
    {{ macro_name }} sram_{{ i }} (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .CLK(clk),
        .CEN(sram_ce_n[{{ i }}]),
        .GWEN(we_n),
{% if write_mask %}
        .WEN(wem_n),
{% else %}
        .WEN({{ data_width }}'b0),  // All bits written when GWEN active
{% endif %}
        .A(sram_addr),
        .D(din),
        .Q(sram_dout_{{ i }})
    );

{% endfor %}
{% if output_routing == "mux" %}
    // Output multiplexer
    reg [{{ data_width - 1 }}:0] dout_mux;

    always @(*) begin
        case (sram_sel)
{% for i in range(sram_count) %}
            {{ select_bits }}'d{{ i }}: dout_mux = sram_dout_{{ i }};
{% endfor %}
            default: dout_mux = {{ data_width }}'h0;
        endcase
    end

    assign dout = dout_mux;
{% elif output_routing == "tristate" %}
    // Tri-state output buffers
{% for i in range(sram_count) %}
    assign dout = (!sram_ce_n[{{ i }}] && we_n) ? sram_dout_{{ i }} : {{ data_width }}'bz;
{% endfor %}
{% elif output_routing == "tristate_registered" %}
    // Registered SRAM select for output timing
    reg [{{ select_bits - 1 }}:0] sram_sel_r;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            sram_sel_r <= {{ select_bits }}'b0;
        else if (!ce_n && we_n)  // Register on read
            sram_sel_r <= sram_sel;
    end

    // Tri-state output buffers (registered select)
{% for i in range(sram_count) %}
    assign dout = (sram_sel_r == {{ select_bits }}'d{{ i }}) ? sram_dout_{{ i }} : {{ data_width }}'bz;
{% endfor %}
{% endif %}

endmodule

`default_nettype wire
