# SPDX-FileCopyrightText: (C) 2025 sram-forge
# SPDX-License-Identifier: Apache-2.0

"""SRAM testbench utilities for {{ chip.name }}.

Generated by sram-forge - do not edit manually.

This module provides shared helper functions for SRAM testing through
the chip pad interface.

Configuration:
    Total SRAMs: {{ sram_count }}
    SRAM Size: {{ sram.size }} words
    Total Words: {{ total_words }}
    Address Bits: {{ addr_bits }}
    Data Width: {{ data_width }}
"""

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import Timer, RisingEdge, ClockCycles

from sram_model import SramModel


# =============================================================================
# Pad Mapping Constants
# =============================================================================
# bidir_PAD bit assignments:
#   [0:{{ data_width - 1 }}]                    = Data bus (bidirectional)
#   [{{ data_width }}]                          = CE_n (chip enable, active low)
#   [{{ data_width + 1 }}]                      = WE_n (write enable, active low)
#   [{{ data_width + 2 }}:{{ data_width + 1 + addr_bits }}] = Address bus

DATA_WIDTH = {{ data_width }}
ADDR_BITS = {{ addr_bits }}
SRAM_COUNT = {{ sram_count }}
SRAM_SIZE = {{ sram.size }}
TOTAL_WORDS = {{ total_words }}

# Bit positions in bidir_PAD
DATA_LSB = 0
DATA_MSB = DATA_WIDTH - 1
CE_N_BIT = DATA_WIDTH
WE_N_BIT = DATA_WIDTH + 1
ADDR_LSB = DATA_WIDTH + 2
ADDR_MSB = DATA_WIDTH + 1 + ADDR_BITS


# =============================================================================
# Startup and Reset
# =============================================================================

async def start_clock(dut, freq_mhz=25):
    """Start the chip clock at specified frequency.

    Args:
        dut: Device under test
        freq_mhz: Clock frequency in MHz (default 25)
    """
    period_ns = 1000 / freq_mhz
    clock = Clock(dut.clk_PAD, period_ns, units="ns")
    cocotb.start_soon(clock.start())


async def reset_chip(dut, time_ns=1000):
    """Reset the chip.

    Args:
        dut: Device under test
        time_ns: Reset hold time in nanoseconds
    """
    cocotb.log.info("Asserting reset...")
    dut.rst_n_PAD.value = 0
    await Timer(time_ns, "ns")
    dut.rst_n_PAD.value = 1
    cocotb.log.info("Reset deasserted")
    await Timer(100, "ns")


async def set_defaults(dut):
    """Set default input values (inactive state).

    All control signals inactive (active-low signals set to 1).
    """
    # Set all bidir pads to default inactive state
    # CE_n=1 (disabled), WE_n=1 (read mode), data=0, addr=0
    default_value = (1 << CE_N_BIT) | (1 << WE_N_BIT)
    dut.bidir_PAD.value = default_value
    dut.input_PAD.value = 0


async def startup(dut, freq_mhz=25):
    """Complete startup sequence.

    Args:
        dut: Device under test
        freq_mhz: Clock frequency in MHz
    """
    await set_defaults(dut)
    await start_clock(dut, freq_mhz)
    await reset_chip(dut)


# =============================================================================
# SRAM Access Through Pads
# =============================================================================

def build_bidir_value(addr=0, data=0, ce_n=1, we_n=1):
    """Build the bidir_PAD value from components.

    This is a public utility function for building the combined bidir_PAD
    value used to drive control signals and data through the chip pads.

    Args:
        addr: Address value
        data: Data value (for writes)
        ce_n: Chip enable (1=disabled, 0=enabled)
        we_n: Write enable (1=read, 0=write)

    Returns:
        Combined bidir_PAD value
    """
    value = 0
    value |= (data & ((1 << DATA_WIDTH) - 1)) << DATA_LSB
    value |= (1 if ce_n else 0) << CE_N_BIT
    value |= (1 if we_n else 0) << WE_N_BIT
    value |= (addr & ((1 << ADDR_BITS) - 1)) << ADDR_LSB
    return value


async def write_sram(dut, addr, data):
    """Write a word to SRAM through chip pad interface.

    Args:
        dut: Device under test
        addr: Address to write
        data: Data to write (8-bit)
    """
    # Setup address and data with CE_n=0, WE_n=0 (write)
    dut.bidir_PAD.value = build_bidir_value(addr=addr, data=data, ce_n=0, we_n=0)
    await RisingEdge(dut.clk_PAD)

    # Deassert controls
    dut.bidir_PAD.value = build_bidir_value(addr=0, data=0, ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)


async def read_sram(dut, addr):
    """Read a word from SRAM through chip pad interface.

    Args:
        dut: Device under test
        addr: Address to read

    Returns:
        Data value read (8-bit)
    """
    # Setup address with CE_n=0, WE_n=1 (read)
    dut.bidir_PAD.value = build_bidir_value(addr=addr, data=0, ce_n=0, we_n=1)
    await RisingEdge(dut.clk_PAD)
    await RisingEdge(dut.clk_PAD)  # Wait for output
    await Timer(1, "ns")  # Allow signal to settle (avoid race condition)

    # Read data from bidir_PAD (lower DATA_WIDTH bits)
    bidir_val = int(dut.bidir_PAD.value)
    data = bidir_val & ((1 << DATA_WIDTH) - 1)

    # Deassert controls
    dut.bidir_PAD.value = build_bidir_value(addr=0, data=0, ce_n=1, we_n=1)

    return data


async def write_sram_no_enable(dut, addr, data):
    """Attempt write with CE_n=1 (should have no effect).

    Used to verify CE_n properly gates writes.

    Args:
        dut: Device under test
        addr: Address to write
        data: Data to write
    """
    # Setup address and data with CE_n=1 (disabled), WE_n=0 (write mode)
    dut.bidir_PAD.value = build_bidir_value(addr=addr, data=data, ce_n=1, we_n=0)
    await RisingEdge(dut.clk_PAD)

    # Deassert controls
    dut.bidir_PAD.value = build_bidir_value(addr=0, data=0, ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)


async def read_sram_no_enable(dut, addr):
    """Attempt read with CE_n=1 (should not change output).

    Used to verify CE_n properly gates reads.

    Args:
        dut: Device under test
        addr: Address to read

    Returns:
        Data value on output (may be stale/undefined)
    """
    # Setup address with CE_n=1 (disabled), WE_n=1 (read mode)
    dut.bidir_PAD.value = build_bidir_value(addr=addr, data=0, ce_n=1, we_n=1)
    await RisingEdge(dut.clk_PAD)
    await RisingEdge(dut.clk_PAD)

    bidir_val = int(dut.bidir_PAD.value)
    data = bidir_val & ((1 << DATA_WIDTH) - 1)

    dut.bidir_PAD.value = build_bidir_value(addr=0, data=0, ce_n=1, we_n=1)

    return data


# =============================================================================
# SRAM Address Helpers
# =============================================================================

def sram_base_addr(sram_index):
    """Get the base address of a specific SRAM block.

    Args:
        sram_index: Index of SRAM (0 to SRAM_COUNT-1)

    Returns:
        Base address of that SRAM block
    """
    return sram_index * SRAM_SIZE


def addr_to_sram_index(addr):
    """Get the SRAM block index for a given address.

    Args:
        addr: Memory address

    Returns:
        Index of SRAM block containing that address
    """
    return addr // SRAM_SIZE


# =============================================================================
# Model Helpers
# =============================================================================

def create_model():
    """Create a fresh behavioral model for verification."""
    return SramModel(TOTAL_WORDS, DATA_WIDTH)
