"""cocotb testbench for {{ chip.name }}

Generated by sram-forge
{% if chip.description %}{{ chip.description }}{% endif %}

Configuration:
  Total SRAMs: {{ sram_count }}
  Total Words: {{ total_words }}
  Address Bits: {{ addr_bits }}
  Data Width: {{ data_width }}
"""

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge, FallingEdge, Timer
from cocotb.result import TestFailure

from sram_model import SramModel


async def reset_dut(dut):
    """Reset the DUT."""
    dut.rst_n.value = 0
    dut.ce_n.value = 1
    dut.we_n.value = 1
    dut.addr.value = 0
    dut.din.value = 0
{% if write_mask %}
    dut.wem_n.value = 0xFF
{% endif %}
    await Timer(100, units="ns")
    dut.rst_n.value = 1
    await Timer(100, units="ns")


async def write_word(dut, addr, data):
    """Write a word to the SRAM."""
    dut.addr.value = addr
    dut.din.value = data
    dut.ce_n.value = 0
    dut.we_n.value = 0
{% if write_mask %}
    dut.wem_n.value = 0x00  # Write all bits
{% endif %}
    await RisingEdge(dut.clk)
    dut.ce_n.value = 1
    dut.we_n.value = 1
    await RisingEdge(dut.clk)


async def read_word(dut, addr):
    """Read a word from the SRAM."""
    dut.addr.value = addr
    dut.ce_n.value = 0
    dut.we_n.value = 1  # Read mode
    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)  # Wait for output
    data = int(dut.dout.value)
    dut.ce_n.value = 1
    return data


@cocotb.test()
async def test_write_read_basic(dut):
    """Test basic write and read operations."""
    clock = Clock(dut.clk, 40, units="ns")  # 25 MHz
    cocotb.start_soon(clock.start())

    model = SramModel({{ total_words }}, {{ data_width }})
    await reset_dut(dut)

    # Test a few addresses
    test_data = [
        (0, 0xAA),
        (1, 0x55),
        ({{ total_words - 1 }}, 0xFF),
        ({{ total_words // 2 }}, 0x12),
    ]

    # Write phase
    for addr, data in test_data:
        await write_word(dut, addr, data)
        model.write(addr, data)
        dut._log.info(f"Wrote 0x{data:02X} to address 0x{addr:04X}")

    # Read phase
    for addr, expected in test_data:
        actual = await read_word(dut, addr)
        model_data = model.read(addr)
        dut._log.info(f"Read 0x{actual:02X} from address 0x{addr:04X} (expected 0x{expected:02X})")
        assert actual == expected, f"Mismatch at 0x{addr:04X}: got 0x{actual:02X}, expected 0x{expected:02X}"
        assert actual == model_data, f"Model mismatch at 0x{addr:04X}"


@cocotb.test()
async def test_write_read_all_srams(dut):
    """Test write/read to each SRAM block."""
    clock = Clock(dut.clk, 40, units="ns")
    cocotb.start_soon(clock.start())

    model = SramModel({{ total_words }}, {{ data_width }})
    await reset_dut(dut)

    # Write to first address of each SRAM block
    sram_size = {{ sram.size }}
    for i in range({{ sram_count }}):
        addr = i * sram_size
        data = (i + 1) & 0xFF
        await write_word(dut, addr, data)
        model.write(addr, data)
        dut._log.info(f"SRAM {i}: Wrote 0x{data:02X} to address 0x{addr:04X}")

    # Read back from each SRAM
    for i in range({{ sram_count }}):
        addr = i * sram_size
        expected = (i + 1) & 0xFF
        actual = await read_word(dut, addr)
        dut._log.info(f"SRAM {i}: Read 0x{actual:02X} from address 0x{addr:04X}")
        assert actual == expected, f"SRAM {i} mismatch: got 0x{actual:02X}, expected 0x{expected:02X}"


@cocotb.test()
async def test_address_boundary(dut):
    """Test address decoding at SRAM boundaries."""
    clock = Clock(dut.clk, 40, units="ns")
    cocotb.start_soon(clock.start())

    model = SramModel({{ total_words }}, {{ data_width }})
    await reset_dut(dut)

    sram_size = {{ sram.size }}

    # Test boundary addresses
    boundary_tests = [
        (sram_size - 1, 0xAA),      # Last address of SRAM 0
        (sram_size, 0x55),          # First address of SRAM 1
        (sram_size * 2 - 1, 0xBB),  # Last address of SRAM 1
        (sram_size * 2, 0xCC),      # First address of SRAM 2
    ]

    # Write phase
    for addr, data in boundary_tests:
        if addr < {{ total_words }}:
            await write_word(dut, addr, data)
            model.write(addr, data)
            dut._log.info(f"Boundary write: 0x{data:02X} to 0x{addr:04X}")

    # Read phase
    for addr, expected in boundary_tests:
        if addr < {{ total_words }}:
            actual = await read_word(dut, addr)
            dut._log.info(f"Boundary read: 0x{actual:02X} from 0x{addr:04X} (expected 0x{expected:02X})")
            assert actual == expected, f"Boundary mismatch at 0x{addr:04X}"


@cocotb.test()
async def test_sequential_write_read(dut):
    """Test sequential write followed by read."""
    clock = Clock(dut.clk, 40, units="ns")
    cocotb.start_soon(clock.start())

    model = SramModel({{ total_words }}, {{ data_width }})
    await reset_dut(dut)

    # Write 256 sequential addresses
    for addr in range(min(256, {{ total_words }})):
        data = addr & 0xFF
        await write_word(dut, addr, data)
        model.write(addr, data)

    # Read back and verify
    errors = 0
    for addr in range(min(256, {{ total_words }})):
        expected = addr & 0xFF
        actual = await read_word(dut, addr)
        if actual != expected:
            dut._log.error(f"Sequential mismatch at 0x{addr:04X}: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1

    assert errors == 0, f"Sequential test had {errors} errors"
    dut._log.info("Sequential write/read test passed")


{% if write_mask %}
@cocotb.test()
async def test_write_mask(dut):
    """Test per-bit write masking."""
    clock = Clock(dut.clk, 40, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    addr = 0x100

    # Write initial value
    await write_word(dut, addr, 0xFF)

    # Write with mask (only lower nibble)
    dut.addr.value = addr
    dut.din.value = 0x00
    dut.ce_n.value = 0
    dut.we_n.value = 0
    dut.wem_n.value = 0xF0  # Mask upper nibble (don't write)
    await RisingEdge(dut.clk)
    dut.ce_n.value = 1
    dut.we_n.value = 1
    await RisingEdge(dut.clk)

    # Read back - should be 0xF0 (upper nibble preserved, lower cleared)
    actual = await read_word(dut, addr)
    expected = 0xF0
    assert actual == expected, f"Write mask test failed: got 0x{actual:02X}, expected 0x{expected:02X}"
    dut._log.info("Write mask test passed")
{% endif %}
