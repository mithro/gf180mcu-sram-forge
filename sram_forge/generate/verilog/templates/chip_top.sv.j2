// Chip Top Module with IO Pads
// Generated by sram-forge
// Chip: {{ chip.name }}
{% if chip.description %}// {{ chip.description }}{% endif %}

// This is the top-level module with IO pad connections
// Uses GF180MCU IO pad library

module {{ chip.name }}_top (
    // Power pads (directly connected)
    inout  wire VDD,
    inout  wire VSS,

    // Clock and reset pads
    inout  wire clk_pad,
    inout  wire rst_n_pad,

    // Control pads
    inout  wire ce_n_pad,
    inout  wire we_n_pad,

    // Address pads
{% for i in range(addr_bits) %}
    inout  wire addr_pad_{{ i }},
{% endfor %}

    // Data pads (directly inout for simplicity)
{% for i in range(data_width) %}
    inout  wire data_pad_{{ i }}{% if not loop.last or config.interface.unified_bus.write_mask %},{% endif %}

{% endfor %}
{% if config.interface.unified_bus.write_mask %}
    // Write mask pads
{% for i in range(data_width) %}
    inout  wire wem_n_pad_{{ i }}{% if not loop.last %},{% endif %}

{% endfor %}
{% endif %}
);

    // Internal signals
    wire clk_core;
    wire rst_n_core;
    wire ce_n_core;
    wire we_n_core;
    wire [{{ addr_bits - 1 }}:0] addr_core;
    wire [{{ data_width - 1 }}:0] din_core;
    wire [{{ data_width - 1 }}:0] dout_core;
{% if config.interface.unified_bus.write_mask %}
    wire [{{ data_width - 1 }}:0] wem_n_core;
{% endif %}

    // IO Pad instantiations
    // Clock input pad
    gf180mcu_fd_io__in_s clk_pad_inst (
        .PAD(clk_pad),
        .PU(1'b0),
        .PD(1'b0),
        .Y(clk_core),
        .DVDD(VDD),
        .DVSS(VSS),
        .VDD(VDD),
        .VSS(VSS)
    );

    // Reset input pad
    gf180mcu_fd_io__in_s rst_n_pad_inst (
        .PAD(rst_n_pad),
        .PU(1'b1),
        .PD(1'b0),
        .Y(rst_n_core),
        .DVDD(VDD),
        .DVSS(VSS),
        .VDD(VDD),
        .VSS(VSS)
    );

    // Chip enable input pad
    gf180mcu_fd_io__in_s ce_n_pad_inst (
        .PAD(ce_n_pad),
        .PU(1'b1),
        .PD(1'b0),
        .Y(ce_n_core),
        .DVDD(VDD),
        .DVSS(VSS),
        .VDD(VDD),
        .VSS(VSS)
    );

    // Write enable input pad
    gf180mcu_fd_io__in_s we_n_pad_inst (
        .PAD(we_n_pad),
        .PU(1'b1),
        .PD(1'b0),
        .Y(we_n_core),
        .DVDD(VDD),
        .DVSS(VSS),
        .VDD(VDD),
        .VSS(VSS)
    );

    // Address input pads
{% for i in range(addr_bits) %}
    gf180mcu_fd_io__in_s addr_pad_{{ i }}_inst (
        .PAD(addr_pad_{{ i }}),
        .PU(1'b0),
        .PD(1'b1),
        .Y(addr_core[{{ i }}]),
        .DVDD(VDD),
        .DVSS(VSS),
        .VDD(VDD),
        .VSS(VSS)
    );
{% endfor %}

    // Data bidirectional pads
{% for i in range(data_width) %}
    gf180mcu_fd_io__bi_t data_pad_{{ i }}_inst (
        .PAD(data_pad_{{ i }}),
        .A(dout_core[{{ i }}]),
        .EN(!we_n_core && !ce_n_core),  // Output enable on read
        .PU(1'b0),
        .PD(1'b0),
        .CS(1'b0),
        .SL(1'b0),
        .IE(1'b1),
        .OE(!we_n_core && !ce_n_core),
        .Y(din_core[{{ i }}]),
        .DVDD(VDD),
        .DVSS(VSS),
        .VDD(VDD),
        .VSS(VSS)
    );
{% endfor %}

{% if config.interface.unified_bus.write_mask %}
    // Write mask input pads
{% for i in range(data_width) %}
    gf180mcu_fd_io__in_s wem_n_pad_{{ i }}_inst (
        .PAD(wem_n_pad_{{ i }}),
        .PU(1'b0),
        .PD(1'b0),
        .Y(wem_n_core[{{ i }}]),
        .DVDD(VDD),
        .DVSS(VSS),
        .VDD(VDD),
        .VSS(VSS)
    );
{% endfor %}
{% endif %}

    // Core instantiation
    {{ chip.name }}_core u_core (
        .clk(clk_core),
        .rst_n(rst_n_core),
        .ce_n(ce_n_core),
        .we_n(we_n_core),
        .addr(addr_core),
        .din(din_core),
        .dout(dout_core)
{% if config.interface.unified_bus.write_mask %}
        ,.wem_n(wem_n_core)
{% endif %}
    );

endmodule
