# SPDX-FileCopyrightText: (C) 2025 sram-forge
# SPDX-License-Identifier: Apache-2.0

"""Chip-level testbench for {{ chip.name }}.

Generated by sram-forge - do not edit manually.

This is the main testbench runner that executes all test modules:
- chip_top_tb: Basic smoke tests
- test_control_signals: CE_n/WE_n protocol verification
- test_sram_selection: SRAM block isolation and routing tests
"""

import os
import logging
from pathlib import Path

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import Timer, ClockCycles, RisingEdge
from cocotb_tools.runner import get_runner

# Import shared utilities
from sram_utils import (
    startup, create_model,
    write_sram, read_sram,
    TOTAL_WORDS, SRAM_SIZE, SRAM_COUNT, DATA_WIDTH, ADDR_BITS,
)

sim = os.getenv("SIM", "icarus")
pdk_root = os.getenv("PDK_ROOT", Path("~/.ciel").expanduser())
pdk = os.getenv("PDK", "gf180mcuD")
scl = os.getenv("SCL", "gf180mcu_fd_sc_mcu7t5v0")
gl = os.getenv("GL", False)
slot = os.getenv("SLOT", "{{ slot }}")

hdl_toplevel = "{{ chip.name }}_top"


# =============================================================================
# Basic Smoke Tests
# =============================================================================

@cocotb.test()
async def test_startup(dut):
    """Verify chip starts up correctly."""
    logger = logging.getLogger("{{ chip.name }}_tb")
    logger.info("Testing startup sequence...")

    await startup(dut)

    logger.info("Startup complete, running for 10 cycles...")
    await ClockCycles(dut.clk_PAD, 10)

    logger.info("PASS: Chip startup successful")


@cocotb.test()
async def test_basic_write_read(dut):
    """Basic write/read smoke test through chip pads."""
    logger = logging.getLogger("{{ chip.name }}_tb")

    await startup(dut)
    model = create_model()

    test_cases = [
        (0x0000, 0xAA),
        (0x0001, 0x55),
        (TOTAL_WORDS - 1, 0xFF),
        (TOTAL_WORDS // 2, 0x12),
    ]

    # Write phase
    for addr, data in test_cases:
        await write_sram(dut, addr, data)
        model.write(addr, data)
        logger.info(f"Wrote 0x{data:02X} to 0x{addr:04X}")

    # Read phase
    errors = 0
    for addr, expected in test_cases:
        actual = await read_sram(dut, addr)
        if actual != expected:
            logger.error(f"Mismatch at 0x{addr:04X}: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1
        else:
            logger.info(f"Read 0x{actual:02X} from 0x{addr:04X} OK")

    assert errors == 0, f"Basic write/read had {errors} errors"
    logger.info("PASS: Basic write/read through pads works")


@cocotb.test()
async def test_all_srams_accessible(dut):
    """Verify each SRAM block is accessible through chip pads."""
    logger = logging.getLogger("{{ chip.name }}_tb")

    await startup(dut)
    model = create_model()

    logger.info(f"Testing access to {SRAM_COUNT} SRAM blocks")

    # Write to first address of each SRAM
    for i in range(SRAM_COUNT):
        addr = i * SRAM_SIZE
        data = (i + 1) & 0xFF
        await write_sram(dut, addr, data)
        model.write(addr, data)

    # Read back
    errors = 0
    for i in range(SRAM_COUNT):
        addr = i * SRAM_SIZE
        expected = (i + 1) & 0xFF
        actual = await read_sram(dut, addr)
        if actual != expected:
            logger.error(f"SRAM[{i}] mismatch at 0x{addr:04X}: got 0x{actual:02X}")
            errors += 1

    assert errors == 0, f"{errors} SRAMs not accessible"
    logger.info("PASS: All SRAMs accessible through pads")


# =============================================================================
# Test Runner
# =============================================================================

def chip_top_runner():
    """Run the chip testbench with all test modules."""
    proj_path = Path(__file__).resolve().parent

    sources = []
    defines = {f"SLOT_{slot.upper()}": True}
    includes = [proj_path / "../src/"]

    if gl:
        # SCL models for gate-level simulation
        sources.append(Path(pdk_root) / pdk / "libs.ref" / scl / "verilog" / f"{scl}.v")
        sources.append(Path(pdk_root) / pdk / "libs.ref" / scl / "verilog" / "primitives.v")

        # Use the powered netlist
        sources.append(proj_path / f"../final/pnl/{hdl_toplevel}.pnl.v")

        defines = {"FUNCTIONAL": True, "USE_POWER_PINS": True}
    else:
        sources.append(proj_path / "../src/{{ chip.name }}_top.sv")
        sources.append(proj_path / "../src/{{ chip.name }}_core.sv")
        sources.append(proj_path / "../src/{{ chip.name }}_sram_array.sv")

    sources += [
        # IO pad models
        Path(pdk_root) / pdk / "libs.ref/gf180mcu_fd_io/verilog/gf180mcu_fd_io.v",
        Path(pdk_root) / pdk / "libs.ref/gf180mcu_fd_io/verilog/gf180mcu_ws_io.v",

        # SRAM macros
        Path(pdk_root) / pdk / "libs.ref/gf180mcu_fd_ip_sram/verilog/{{ config.memory.macro }}.v",

        # Custom IP
        proj_path / "../ip/gf180mcu_ws_ip__id/vh/gf180mcu_ws_ip__id.v",
        proj_path / "../ip/gf180mcu_ws_ip__logo/vh/gf180mcu_ws_ip__logo.v",
    ]

    build_args = []

    if sim == "icarus":
        pass

    if sim == "verilator":
        build_args = ["--timing", "--trace", "--trace-fst", "--trace-structs"]

    runner = get_runner(sim)
    runner.build(
        sources=sources,
        hdl_toplevel=hdl_toplevel,
        defines=defines,
        always=True,
        includes=includes,
        build_args=build_args,
        waves=True,
    )

    plusargs = []

    # Run all test modules
    runner.test(
        hdl_toplevel=hdl_toplevel,
        test_module="chip_top_tb,test_control_signals,test_sram_selection",
        plusargs=plusargs,
        waves=True,
    )


if __name__ == "__main__":
    chip_top_runner()
