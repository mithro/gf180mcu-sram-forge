"""Python behavioral model for {{ chip.name }}

Generated by sram-forge
{% if chip.description %}{{ chip.description }}{% endif %}

This model provides a reference implementation for verification.
It models the expected behavior of the SRAM array.
"""


class SramModel:
    """Behavioral model of the SRAM array.

    Configuration:
        Total Words: {{ total_words }}
        Data Width: {{ data_width }} bits
        Address Bits: {{ addr_bits }}
        SRAM Count: {{ sram_count }}
    """

    def __init__(self, size: int = {{ total_words }}, width: int = {{ data_width }}):
        """Initialize the SRAM model.

        Args:
            size: Number of addressable words.
            width: Bits per word.
        """
        self.size = size
        self.width = width
        self.mask = (1 << width) - 1  # Data mask (0xFF for 8-bit)

        # Initialize memory to zero
        self.memory = [0] * size

    def write(self, addr: int, data: int, wem: int = 0) -> None:
        """Write data to memory.

        Args:
            addr: Address to write to.
            data: Data to write.
            wem: Write enable mask (active low). 0 = write bit, 1 = preserve bit.
        """
        if addr >= self.size:
            raise ValueError(f"Address 0x{addr:X} out of range (max 0x{self.size - 1:X})")

        data = data & self.mask

{% if write_mask %}
        # Apply write mask
        if wem != 0:
            # Preserve bits where wem is 1
            old_data = self.memory[addr]
            data = (old_data & wem) | (data & ~wem & self.mask)
{% endif %}

        self.memory[addr] = data

    def read(self, addr: int) -> int:
        """Read data from memory.

        Args:
            addr: Address to read from.

        Returns:
            Data at the address.
        """
        if addr >= self.size:
            raise ValueError(f"Address 0x{addr:X} out of range (max 0x{self.size - 1:X})")

        return self.memory[addr]

    def dump(self, start: int = 0, count: int = 16) -> str:
        """Dump memory contents for debugging.

        Args:
            start: Starting address.
            count: Number of words to dump.

        Returns:
            Formatted memory dump string.
        """
        lines = []
        for i in range(count):
            addr = start + i
            if addr >= self.size:
                break
            data = self.memory[addr]
            lines.append(f"0x{addr:04X}: 0x{data:02X}")
        return "\n".join(lines)

    def clear(self) -> None:
        """Clear all memory to zero."""
        self.memory = [0] * self.size

    def fill(self, pattern: int) -> None:
        """Fill all memory with a pattern.

        Args:
            pattern: Pattern to fill with.
        """
        pattern = pattern & self.mask
        self.memory = [pattern] * self.size


# Standalone test
if __name__ == "__main__":
    model = SramModel()
    print(f"SRAM Model: {model.size} words x {model.width} bits")

    # Test basic operations
    model.write(0, 0xAA)
    model.write(1, 0x55)
    last_addr = {{ total_words - 1 }}
    model.write(last_addr, 0xFF)

    print("\nMemory dump:")
    print(model.dump(0, 4))

    print(f"\nRead from 0x0000: 0x{model.read(0):02X}")
    print(f"Read from 0x0001: 0x{model.read(1):02X}")
    print(f"Read from 0x{last_addr:04X}: 0x{model.read(last_addr):02X}")
