"""Package generator for sram-forge.

Creates a complete buildable project by:
1. Copying infrastructure from gf180mcu-sram-only template
2. Generating chip-specific files (Verilog, LibreLane, testbench, docs)
3. Initializing git repository
"""

from datetime import datetime
from pathlib import Path
import shutil
import subprocess

from jinja2 import Environment, BaseLoader

from sram_forge.models import ChipConfig, SramSpec, SlotSpec
from sram_forge.calc.fit import FitResult
from sram_forge.generate.verilog.engine import VerilogEngine
from sram_forge.generate.librelane.engine import LibreLaneEngine
from sram_forge.generate.testbench.engine import TestbenchEngine
from sram_forge.generate.docs.engine import DocumentationEngine


MANIFEST_TEMPLATE = """\
# sram-forge Package Manifest
# Generated: {{ timestamp }}

package:
  name: {{ package_name }}
  version: "1.0.0"
  generator: sram-forge

chip:
  name: {{ chip.name }}
  description: {{ chip.description | default('') }}

memory:
  macro: {{ config.memory.macro }}
  count: {{ sram_count }}
  total_words: {{ total_words }}
  total_bits: {{ total_bits }}
  address_bits: {{ addr_bits }}
  data_width: {{ data_width }}

slot: {{ config.slot }}
interface: {{ config.interface.scheme }}

files:
  verilog:
    - src/{{ chip.name }}_sram_array.sv
    - src/{{ chip.name }}_core.sv
    - src/{{ chip.name }}_top.sv
  librelane:
    - librelane/config.yaml
    - librelane/pdn_cfg.tcl
    - librelane/{{ chip.name }}_top.sdc
  testbench:
    - cocotb/chip_top_tb.py
    - cocotb/sram_utils.py
    - cocotb/sram_model.py
    - cocotb/test_control_signals.py
    - cocotb/test_sram_selection.py
  docs:
    - docs/README.md
    - docs/datasheet.md
    - docs/memory_map.md
"""


README_TEMPLATE = """\
# {{ chip.name }}

{% if chip.description %}{{ chip.description }}{% endif %}

Generated by [sram-forge](https://github.com/wafer-space/gf180mcu-sram-only) for GF180MCU PDK.

## Specifications

| Parameter | Value |
|-----------|-------|
| Total Capacity | {{ total_words }} words x {{ data_width }} bits |
| Total Size | {{ total_bytes }} bytes |
| Address Width | {{ addr_bits }} bits |
| Data Width | {{ data_width }} bits |
| SRAM Macros | {{ sram_count }} |
| Slot | {{ config.slot }} |

## Building

```bash
# Enter development environment
nix-shell  # or: nix develop

# Build with LibreLane
make librelane

# Run verification
make cocotb
```

## Project Structure

```
├── src/                    # Verilog sources
│   ├── {{ chip.name }}_sram_array.sv
│   ├── {{ chip.name }}_core.sv
│   └── {{ chip.name }}_top.sv
├── librelane/              # Physical design config
│   ├── config.yaml
│   ├── pdn_cfg.tcl
│   └── {{ chip.name }}_top.sdc
├── cocotb/                 # Verification testbench
└── docs/                   # Documentation
```

## License

See LICENSE file.
"""


def get_template_dir() -> Path:
    """Get path to the project template directory.

    Returns the bundled project_template directory within the package.
    """
    # Template files are bundled in sram_forge/generate/package/project_template/
    return Path(__file__).resolve().parent / "project_template"


class PackageEngine:
    """Project package generator using template cloning."""

    # Infrastructure files/dirs to copy from template
    COPY_FILES = [
        "flake.nix",
        "flake.lock",
        "shell.nix",
        "Makefile",
        "LICENSE",
        "AUTHORS.md",
        ".gitignore",
    ]

    COPY_DIRS = [
        ".github",
        "scripts",
        "ip",
        "librelane/slots",
    ]

    def __init__(self, template_dir: Path | None = None):
        """Initialize the package engine.

        Args:
            template_dir: Path to project template. Auto-detected if None.
        """
        self.template_dir = template_dir or get_template_dir()
        self.verilog_engine = VerilogEngine()
        self.librelane_engine = LibreLaneEngine()
        self.testbench_engine = TestbenchEngine()
        self.docs_engine = DocumentationEngine()

        self.env = Environment(loader=BaseLoader())
        self.manifest_template = self.env.from_string(MANIFEST_TEMPLATE)
        self.readme_template = self.env.from_string(README_TEMPLATE)

    def generate_manifest(
        self,
        chip_config: ChipConfig,
        sram_spec: SramSpec,
        fit_result: FitResult,
        package_name: str,
    ) -> str:
        """Generate package manifest.

        Args:
            chip_config: Chip configuration.
            sram_spec: SRAM macro specification.
            fit_result: Fit calculation result.
            package_name: Name for the package.

        Returns:
            Generated manifest YAML.
        """
        return self.manifest_template.render(
            chip=chip_config.chip,
            config=chip_config,
            sram=sram_spec,
            fit=fit_result,
            package_name=package_name,
            timestamp=datetime.now().isoformat(),
            data_width=sram_spec.width,
            addr_bits=fit_result.address_bits,
            sram_count=fit_result.count,
            total_words=fit_result.total_words,
            total_bits=fit_result.total_bits,
        )

    def generate_readme(
        self,
        chip_config: ChipConfig,
        sram_spec: SramSpec,
        fit_result: FitResult,
    ) -> str:
        """Generate project README.

        Args:
            chip_config: Chip configuration.
            sram_spec: SRAM macro specification.
            fit_result: Fit calculation result.

        Returns:
            Generated README markdown.
        """
        return self.readme_template.render(
            chip=chip_config.chip,
            config=chip_config,
            sram=sram_spec,
            fit=fit_result,
            data_width=sram_spec.width,
            addr_bits=fit_result.address_bits,
            sram_count=fit_result.count,
            total_words=fit_result.total_words,
            total_bits=fit_result.total_bits,
            total_bytes=fit_result.total_bits // 8,
        )

    def create_package(
        self,
        chip_config: ChipConfig,
        sram_spec: SramSpec,
        slot_spec: SlotSpec,
        fit_result: FitResult,
        package_name: str,
        output_dir: Path,
        init_git: bool = True,
    ) -> Path:
        """Create a complete project package.

        Args:
            chip_config: Chip configuration.
            sram_spec: SRAM macro specification.
            slot_spec: Slot specification.
            fit_result: Fit calculation result.
            package_name: Name for the package directory.
            output_dir: Parent directory to create package in.
            init_git: Whether to initialize git repository.

        Returns:
            Path to created package directory.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        package_dir = output_dir / package_name

        if package_dir.exists():
            raise ValueError(f"Package directory already exists: {package_dir}")

        package_dir.mkdir()

        # 1. Copy infrastructure from template
        self._copy_infrastructure(package_dir)

        # 2. Generate chip-specific files
        self._generate_verilog(package_dir, chip_config, sram_spec, fit_result)
        self._generate_librelane(package_dir, chip_config, sram_spec, slot_spec, fit_result)
        self._generate_testbench(package_dir, chip_config, sram_spec, fit_result)
        self._generate_docs(package_dir, chip_config, sram_spec, fit_result)

        # 3. Generate manifest and README
        manifest = self.generate_manifest(chip_config, sram_spec, fit_result, package_name)
        (package_dir / "manifest.yaml").write_text(manifest)

        readme = self.generate_readme(chip_config, sram_spec, fit_result)
        (package_dir / "README.md").write_text(readme)

        # 4. Initialize git repository
        if init_git:
            self._init_git(package_dir, chip_config)

        return package_dir

    def _copy_infrastructure(self, package_dir: Path) -> None:
        """Copy infrastructure files from template."""
        # Copy individual files
        for filename in self.COPY_FILES:
            src = self.template_dir / filename
            if src.exists():
                shutil.copy2(src, package_dir / filename)

        # Copy directories
        for dirname in self.COPY_DIRS:
            src = self.template_dir / dirname
            if src.exists():
                dst = package_dir / dirname
                dst.parent.mkdir(parents=True, exist_ok=True)
                shutil.copytree(src, dst)

    def _generate_verilog(
        self,
        package_dir: Path,
        chip_config: ChipConfig,
        sram_spec: SramSpec,
        fit_result: FitResult,
    ) -> None:
        """Generate Verilog files."""
        src_dir = package_dir / "src"
        src_dir.mkdir(exist_ok=True)

        sram_array = self.verilog_engine.generate_sram_array(chip_config, sram_spec, fit_result)
        (src_dir / f"{chip_config.chip.name}_sram_array.sv").write_text(sram_array)

        chip_core = self.verilog_engine.generate_chip_core(chip_config, sram_spec, fit_result)
        (src_dir / f"{chip_config.chip.name}_core.sv").write_text(chip_core)

        chip_top = self.verilog_engine.generate_chip_top(chip_config, sram_spec, fit_result)
        (src_dir / f"{chip_config.chip.name}_top.sv").write_text(chip_top)

    def _generate_librelane(
        self,
        package_dir: Path,
        chip_config: ChipConfig,
        sram_spec: SramSpec,
        slot_spec: SlotSpec,
        fit_result: FitResult,
    ) -> None:
        """Generate LibreLane files."""
        librelane_dir = package_dir / "librelane"
        librelane_dir.mkdir(exist_ok=True)

        ll_config = self.librelane_engine.generate_config(
            chip_config, sram_spec, slot_spec, fit_result
        )
        (librelane_dir / "config.yaml").write_text(ll_config)

        pdn_cfg = self.librelane_engine.generate_pdn(chip_config, sram_spec, slot_spec, fit_result)
        (librelane_dir / "pdn_cfg.tcl").write_text(pdn_cfg)

        sdc = self.librelane_engine.generate_sdc(chip_config, sram_spec, fit_result)
        (librelane_dir / f"{chip_config.chip.name}_top.sdc").write_text(sdc)

    def _generate_testbench(
        self,
        package_dir: Path,
        chip_config: ChipConfig,
        sram_spec: SramSpec,
        fit_result: FitResult,
    ) -> None:
        """Generate testbench files."""
        tb_dir = package_dir / "cocotb"
        tb_dir.mkdir(exist_ok=True)

        # Main testbench runner
        chip_top_tb = self.testbench_engine.generate_chip_top_tb(
            chip_config, sram_spec, fit_result
        )
        (tb_dir / "chip_top_tb.py").write_text(chip_top_tb)

        # Shared utilities
        sram_utils = self.testbench_engine.generate_sram_utils(
            chip_config, sram_spec, fit_result
        )
        (tb_dir / "sram_utils.py").write_text(sram_utils)

        # Behavioral model
        model_py = self.testbench_engine.generate_behavioral_model(
            chip_config, sram_spec, fit_result
        )
        (tb_dir / "sram_model.py").write_text(model_py)

        # Control signal tests
        test_control = self.testbench_engine.generate_test_control_signals(
            chip_config, sram_spec, fit_result
        )
        (tb_dir / "test_control_signals.py").write_text(test_control)

        # SRAM selection tests
        test_selection = self.testbench_engine.generate_test_sram_selection(
            chip_config, sram_spec, fit_result
        )
        (tb_dir / "test_sram_selection.py").write_text(test_selection)

    def _generate_docs(
        self,
        package_dir: Path,
        chip_config: ChipConfig,
        sram_spec: SramSpec,
        fit_result: FitResult,
    ) -> None:
        """Generate documentation files."""
        docs_dir = package_dir / "docs"
        docs_dir.mkdir(exist_ok=True)

        readme = self.docs_engine.generate_readme(chip_config, sram_spec, fit_result)
        (docs_dir / "README.md").write_text(readme)

        datasheet = self.docs_engine.generate_datasheet(chip_config, sram_spec, fit_result)
        (docs_dir / "datasheet.md").write_text(datasheet)

        memory_map = self.docs_engine.generate_memory_map(chip_config, sram_spec, fit_result)
        (docs_dir / "memory_map.md").write_text(memory_map)

    def _init_git(self, package_dir: Path, chip_config: ChipConfig) -> None:
        """Initialize git repository with initial commit."""
        try:
            # Initialize repo
            subprocess.run(
                ["git", "init"],
                cwd=package_dir,
                check=True,
                capture_output=True,
            )

            # Add all files
            subprocess.run(
                ["git", "add", "."],
                cwd=package_dir,
                check=True,
                capture_output=True,
            )

            # Create initial commit
            commit_msg = f"Initial commit: {chip_config.chip.name}\n\nGenerated by sram-forge"
            subprocess.run(
                ["git", "commit", "-m", commit_msg],
                cwd=package_dir,
                check=True,
                capture_output=True,
            )
        except subprocess.CalledProcessError:
            # Git init failed, but package is still usable
            pass
        except FileNotFoundError:
            # Git not installed
            pass
