# SPDX-FileCopyrightText: (C) 2025 sram-forge
# SPDX-License-Identifier: Apache-2.0

"""SRAM selection and isolation tests for {{ chip.name }}.

Generated by sram-forge - do not edit manually.

These tests verify that the address decoder correctly routes operations
to individual SRAM blocks and that there is no cross-talk between SRAMs.

Configuration:
    Total SRAMs: {{ sram_count }}
    SRAM Size: {{ sram.size }} words each
    Total Words: {{ total_words }}
"""

import cocotb
from cocotb.triggers import RisingEdge

from sram_utils import (
    startup, create_model,
    write_sram, read_sram,
    sram_base_addr, addr_to_sram_index,
    TOTAL_WORDS, SRAM_SIZE, SRAM_COUNT,
)


@cocotb.test()
async def test_each_sram_independently_writable(dut):
    """Verify each SRAM block can be written and read independently.

    Write a unique pattern to the first address of each SRAM block,
    then read back all patterns to verify no cross-talk occurred.
    """
    await startup(dut)
    model = create_model()

    dut._log.info(f"Testing {SRAM_COUNT} SRAM blocks, {SRAM_SIZE} words each")

    # Write unique pattern to first address of each SRAM
    for sram_idx in range(SRAM_COUNT):
        addr = sram_base_addr(sram_idx)
        # Unique pattern that encodes the SRAM index
        data = ((sram_idx + 1) * 17) & 0xFF
        await write_sram(dut, addr, data)
        model.write(addr, data)
        dut._log.info(f"SRAM[{sram_idx}]: Wrote 0x{data:02X} to addr 0x{addr:04X}")

    # Read back and verify all patterns
    errors = 0
    for sram_idx in range(SRAM_COUNT):
        addr = sram_base_addr(sram_idx)
        expected = ((sram_idx + 1) * 17) & 0xFF
        actual = await read_sram(dut, addr)

        if actual != expected:
            dut._log.error(f"SRAM[{sram_idx}] mismatch: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1
        else:
            dut._log.info(f"SRAM[{sram_idx}]: Read 0x{actual:02X} OK")

    assert errors == 0, f"{errors} SRAM blocks had incorrect data"
    dut._log.info("PASS: All SRAM blocks independently writable")


@cocotb.test()
async def test_adjacent_sram_isolation(dut):
    """Verify writes to one SRAM don't affect adjacent SRAMs.

    Write to SRAM[i], verify SRAM[i-1] and SRAM[i+1] are unchanged.
    """
    await startup(dut)
    model = create_model()

{% if sram_count < 3 %}
    dut._log.info("Skipping: need at least 3 SRAMs for adjacency test")
    return
{% else %}
    # Initialize all SRAMs with known pattern
    init_pattern = 0xA5
    for sram_idx in range(SRAM_COUNT):
        addr = sram_base_addr(sram_idx)
        await write_sram(dut, addr, init_pattern)
        model.write(addr, init_pattern)

    # Write different pattern to middle SRAM
    target_sram = SRAM_COUNT // 2
    target_addr = sram_base_addr(target_sram)
    new_pattern = 0x5A

    await write_sram(dut, target_addr, new_pattern)
    model.write(target_addr, new_pattern)
    dut._log.info(f"Wrote 0x{new_pattern:02X} to SRAM[{target_sram}] at 0x{target_addr:04X}")

    # Verify adjacent SRAMs unchanged
    errors = 0

    # Check SRAM before
    if target_sram > 0:
        prev_addr = sram_base_addr(target_sram - 1)
        prev_data = await read_sram(dut, prev_addr)
        if prev_data != init_pattern:
            dut._log.error(f"SRAM[{target_sram-1}] corrupted: got 0x{prev_data:02X}, expected 0x{init_pattern:02X}")
            errors += 1
        else:
            dut._log.info(f"SRAM[{target_sram-1}] unchanged (0x{prev_data:02X})")

    # Check target SRAM (should have new value)
    target_data = await read_sram(dut, target_addr)
    if target_data != new_pattern:
        dut._log.error(f"SRAM[{target_sram}] wrong: got 0x{target_data:02X}, expected 0x{new_pattern:02X}")
        errors += 1

    # Check SRAM after
    if target_sram < SRAM_COUNT - 1:
        next_addr = sram_base_addr(target_sram + 1)
        next_data = await read_sram(dut, next_addr)
        if next_data != init_pattern:
            dut._log.error(f"SRAM[{target_sram+1}] corrupted: got 0x{next_data:02X}, expected 0x{init_pattern:02X}")
            errors += 1
        else:
            dut._log.info(f"SRAM[{target_sram+1}] unchanged (0x{next_data:02X})")

    assert errors == 0, f"Adjacent SRAM isolation failed with {errors} errors"
    dut._log.info("PASS: Adjacent SRAM isolation verified")
{% endif %}


@cocotb.test()
async def test_output_from_correct_sram(dut):
    """Verify reads return data from the correct SRAM block.

    Write unique patterns to each SRAM, then read each and verify
    the correct pattern is returned.
    """
    await startup(dut)

    # Write unique pattern to each SRAM at a non-zero offset
    offset = min(10, SRAM_SIZE - 1)  # Use offset 10 within each SRAM
    patterns = {}

    for sram_idx in range(SRAM_COUNT):
        addr = sram_base_addr(sram_idx) + offset
        # Create pattern that encodes both SRAM index and offset
        data = (sram_idx ^ 0xAA) & 0xFF
        patterns[addr] = data
        await write_sram(dut, addr, data)

    dut._log.info(f"Wrote unique patterns to offset {offset} in each SRAM")

    # Read back in reverse order to catch any latching issues
    errors = 0
    for sram_idx in reversed(range(SRAM_COUNT)):
        addr = sram_base_addr(sram_idx) + offset
        expected = patterns[addr]
        actual = await read_sram(dut, addr)

        if actual != expected:
            dut._log.error(f"SRAM[{sram_idx}] output wrong: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1

    assert errors == 0, f"Output routing errors in {errors} SRAMs"
    dut._log.info("PASS: Outputs correctly routed from each SRAM")


@cocotb.test()
async def test_only_one_sram_selected_per_write(dut):
    """Verify writes affect exactly one SRAM block.

    Write to address X in SRAM[i], verify address X in all other SRAMs
    is unchanged.
    """
    await startup(dut)
    model = create_model()

    # Initialize all SRAMs with the same initial pattern at same offset
    internal_offset = 5
    init_pattern = 0x00

    for sram_idx in range(SRAM_COUNT):
        addr = sram_base_addr(sram_idx) + internal_offset
        await write_sram(dut, addr, init_pattern)
        model.write(addr, init_pattern)

    # Write to just one SRAM
    target_sram = 0
    target_addr = sram_base_addr(target_sram) + internal_offset
    write_pattern = 0xFF

    await write_sram(dut, target_addr, write_pattern)
    model.write(target_addr, write_pattern)
    dut._log.info(f"Wrote 0x{write_pattern:02X} to SRAM[{target_sram}] offset {internal_offset}")

    # Verify only target SRAM was modified
    errors = 0
    for sram_idx in range(SRAM_COUNT):
        addr = sram_base_addr(sram_idx) + internal_offset
        actual = await read_sram(dut, addr)

        if sram_idx == target_sram:
            expected = write_pattern
        else:
            expected = init_pattern

        if actual != expected:
            dut._log.error(f"SRAM[{sram_idx}] at offset {internal_offset}: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1

    assert errors == 0, f"Write affected wrong SRAMs ({errors} errors)"
    dut._log.info("PASS: Writes affect exactly one SRAM")


@cocotb.test()
async def test_address_decoder_all_bits(dut):
    """Verify each address bit affects SRAM selection correctly.

    For the upper address bits (SRAM select), verify that toggling
    each bit selects a different SRAM.
    """
    await startup(dut)

    import math
    select_bits = int(math.ceil(math.log2(SRAM_COUNT))) if SRAM_COUNT > 1 else 0

    if select_bits == 0:
        dut._log.info("Skipping: only 1 SRAM, no select bits to test")
        return

    dut._log.info(f"Testing {select_bits} SRAM select bits")

    # Calculate which address bit is the LSB of the select field
    sram_addr_bits = int(math.ceil(math.log2(SRAM_SIZE)))

    # Write unique patterns using addresses that differ in select bits
    for bit in range(select_bits):
        sram_idx = 1 << bit
        if sram_idx >= SRAM_COUNT:
            continue

        addr = sram_base_addr(sram_idx)
        data = 0x10 + bit
        await write_sram(dut, addr, data)
        dut._log.info(f"Select bit {bit}: SRAM[{sram_idx}], addr 0x{addr:04X}, data 0x{data:02X}")

    # Read back and verify
    errors = 0
    for bit in range(select_bits):
        sram_idx = 1 << bit
        if sram_idx >= SRAM_COUNT:
            continue

        addr = sram_base_addr(sram_idx)
        expected = 0x10 + bit
        actual = await read_sram(dut, addr)

        if actual != expected:
            dut._log.error(f"Select bit {bit} failed: got 0x{actual:02X}, expected 0x{expected:02X}")
            errors += 1

    assert errors == 0, f"Address decoder bit test had {errors} errors"
    dut._log.info("PASS: All SRAM select bits work correctly")


@cocotb.test()
async def test_full_address_range_per_sram(dut):
    """Verify the full address range within each SRAM works.

    Write to first and last address of each SRAM block.
    """
    await startup(dut)
    model = create_model()

    errors = 0

    for sram_idx in range(SRAM_COUNT):
        first_addr = sram_base_addr(sram_idx)
        last_addr = sram_base_addr(sram_idx) + SRAM_SIZE - 1

        first_data = (sram_idx * 2) & 0xFF
        last_data = (sram_idx * 2 + 1) & 0xFF

        # Write first and last
        await write_sram(dut, first_addr, first_data)
        await write_sram(dut, last_addr, last_data)
        model.write(first_addr, first_data)
        model.write(last_addr, last_data)

    # Read back all first and last addresses
    for sram_idx in range(SRAM_COUNT):
        first_addr = sram_base_addr(sram_idx)
        last_addr = sram_base_addr(sram_idx) + SRAM_SIZE - 1

        first_expected = (sram_idx * 2) & 0xFF
        last_expected = (sram_idx * 2 + 1) & 0xFF

        first_actual = await read_sram(dut, first_addr)
        last_actual = await read_sram(dut, last_addr)

        if first_actual != first_expected:
            dut._log.error(f"SRAM[{sram_idx}] first addr wrong: got 0x{first_actual:02X}")
            errors += 1

        if last_actual != last_expected:
            dut._log.error(f"SRAM[{sram_idx}] last addr wrong: got 0x{last_actual:02X}")
            errors += 1

    assert errors == 0, f"Full range test had {errors} errors"
    dut._log.info("PASS: Full address range works for all SRAMs")


@cocotb.test()
async def test_boundary_crossing(dut):
    """Verify correct behavior at SRAM block boundaries.

    Write to addresses immediately before and after each boundary.
    """
    await startup(dut)
    model = create_model()

{% if sram_count < 2 %}
    dut._log.info("Skipping: need at least 2 SRAMs for boundary test")
    return
{% else %}
    errors = 0

    # Test each boundary (except the last one which has no SRAM after it)
    for boundary_idx in range(1, SRAM_COUNT):
        # Address just before boundary (last address of SRAM[boundary_idx-1])
        before_addr = sram_base_addr(boundary_idx) - 1
        before_data = 0xBB

        # Address at boundary (first address of SRAM[boundary_idx])
        at_addr = sram_base_addr(boundary_idx)
        at_data = 0xAA

        # Write both
        await write_sram(dut, before_addr, before_data)
        await write_sram(dut, at_addr, at_data)
        model.write(before_addr, before_data)
        model.write(at_addr, at_data)

        # Read back and verify - this checks both address decoder and output mux
        before_actual = await read_sram(dut, before_addr)
        at_actual = await read_sram(dut, at_addr)

        if before_actual != before_data:
            dut._log.error(f"Before boundary {boundary_idx}: got 0x{before_actual:02X}, expected 0x{before_data:02X}")
            errors += 1

        if at_actual != at_data:
            dut._log.error(f"At boundary {boundary_idx}: got 0x{at_actual:02X}, expected 0x{at_data:02X}")
            errors += 1

        # Verify they're in different SRAMs
        before_sram = addr_to_sram_index(before_addr)
        at_sram = addr_to_sram_index(at_addr)
        assert before_sram == boundary_idx - 1, \
            f"before_addr 0x{before_addr:04X} in wrong SRAM: got {before_sram}, expected {boundary_idx - 1}"
        assert at_sram == boundary_idx, \
            f"at_addr 0x{at_addr:04X} in wrong SRAM: got {at_sram}, expected {boundary_idx}"

    assert errors == 0, f"Boundary crossing test had {errors} errors"
    dut._log.info("PASS: SRAM boundary crossing works correctly")
{% endif %}
