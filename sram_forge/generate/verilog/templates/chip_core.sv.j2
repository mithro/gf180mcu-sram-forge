// SPDX-FileCopyrightText: Â© 2025 SRAM Forge Contributors
// SPDX-License-Identifier: Apache-2.0
// Generated by sram-forge
// Chip: {{ chip.name }}
{% if chip.description %}// {{ chip.description }}{% endif %}

// This module maps the generic wafer.space pad interface to SRAM signals
// Pad mapping for this SRAM configuration:
//   bidir[0:{{ data_width - 1 }}]    - Data bus (bidirectional)
//   bidir[{{ data_width }}]           - Chip enable (ce_n, active low)
//   bidir[{{ data_width + 1 }}]           - Write enable (we_n, active low)
//   bidir[{{ data_width + 2 }}:{{ data_width + 1 + addr_bits }}]  - Address bus
//   input[*]           - Unused (directly tied)
//   analog[*]          - Unused (directly connected)

`default_nettype none

module {{ chip.name }}_core #(
    parameter NUM_INPUT_PADS = 12,
    parameter NUM_BIDIR_PADS = 40,
    parameter NUM_ANALOG_PADS = 2
    )(
    `ifdef USE_POWER_PINS
    inout  wire                       VDD,
    inout  wire                       VSS,
    `endif

    // Clock and reset
    input  wire                       clk,
    input  wire                       rst_n,

    // Input pads interface (directly from pads)
    input  wire [NUM_INPUT_PADS-1:0]  input_in,
    output wire [NUM_INPUT_PADS-1:0]  input_pu,
    output wire [NUM_INPUT_PADS-1:0]  input_pd,

    // Bidirectional pads interface
    input  wire [NUM_BIDIR_PADS-1:0]  bidir_in,
    output wire [NUM_BIDIR_PADS-1:0]  bidir_out,
    output wire [NUM_BIDIR_PADS-1:0]  bidir_oe,
    output wire [NUM_BIDIR_PADS-1:0]  bidir_cs,
    output wire [NUM_BIDIR_PADS-1:0]  bidir_sl,
    output wire [NUM_BIDIR_PADS-1:0]  bidir_ie,
    output wire [NUM_BIDIR_PADS-1:0]  bidir_pu,
    output wire [NUM_BIDIR_PADS-1:0]  bidir_pd,

    // Analog pads (directly connected, directly inout)
    inout  wire [NUM_ANALOG_PADS-1:0] analog
);

    // SRAM signals
    localparam DATA_WIDTH = {{ data_width }};
    localparam ADDR_BITS = {{ addr_bits }};

    // Map bidir pads to SRAM signals
    // bidir[0:DATA_WIDTH-1] = data bus
    // bidir[DATA_WIDTH] = ce_n
    // bidir[DATA_WIDTH+1] = we_n
    // bidir[DATA_WIDTH+2:DATA_WIDTH+1+ADDR_BITS] = address

    wire [DATA_WIDTH-1:0] data_in;
    wire [DATA_WIDTH-1:0] data_out;
    wire ce_n;
    wire we_n;
    wire [ADDR_BITS-1:0] addr;

    // Data bus mapping (bidir[0:DATA_WIDTH-1])
    genvar i;
    generate
        for (i = 0; i < DATA_WIDTH; i = i + 1) begin : data_map
            assign data_in[i] = bidir_in[i];
            assign bidir_out[i] = data_out[i];
        end
    endgenerate

    // Control signals mapping
    assign ce_n = bidir_in[DATA_WIDTH];
    assign we_n = bidir_in[DATA_WIDTH + 1];

    // Address mapping (bidir[DATA_WIDTH+2:DATA_WIDTH+1+ADDR_BITS])
    generate
        for (i = 0; i < ADDR_BITS; i = i + 1) begin : addr_map
            assign addr[i] = bidir_in[DATA_WIDTH + 2 + i];
        end
    endgenerate

    // Output enable: active when reading (ce_n=0 and we_n=1)
    wire read_active = !ce_n && we_n;

    // Configure bidir pad controls
    // For data bus: OE active during read, IE always enabled
    // For control/address: OE=0 (input only), IE always enabled
    generate
        // Data bus pads (0 to DATA_WIDTH-1): bidirectional
        for (i = 0; i < DATA_WIDTH; i = i + 1) begin : data_ctrl
            assign bidir_oe[i] = read_active;  // Output enable during read
            assign bidir_ie[i] = 1'b1;         // Input always enabled
            assign bidir_cs[i] = 1'b0;         // No controlled slew
            assign bidir_sl[i] = 1'b0;         // No slew control
            assign bidir_pu[i] = 1'b0;         // No pull-up
            assign bidir_pd[i] = 1'b0;         // No pull-down
        end

        // Control and address pads (DATA_WIDTH onwards): input only
        for (i = DATA_WIDTH; i < NUM_BIDIR_PADS; i = i + 1) begin : ctrl_addr_ctrl
            assign bidir_out[i] = 1'b0;        // No output
            assign bidir_oe[i] = 1'b0;         // Output disabled (input mode)
            assign bidir_ie[i] = 1'b1;         // Input enabled
            assign bidir_cs[i] = 1'b0;
            assign bidir_sl[i] = 1'b0;
            // Pull-ups for active-low control signals
            assign bidir_pu[i] = (i == DATA_WIDTH || i == DATA_WIDTH + 1) ? 1'b1 : 1'b0;
            assign bidir_pd[i] = (i == DATA_WIDTH || i == DATA_WIDTH + 1) ? 1'b0 : 1'b1;
        end
    endgenerate

    // Configure input pads (unused, tie off)
    assign input_pu = {NUM_INPUT_PADS{1'b0}};
    assign input_pd = {NUM_INPUT_PADS{1'b1}};  // Pull-down unused inputs

    // Instantiate SRAM array
    {{ chip.name }}_sram_array u_sram_array (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .clk(clk),
        .rst_n(rst_n),
        .ce_n(ce_n),
        .we_n(we_n),
        .addr(addr),
        .din(data_in),
        .dout(data_out)
{% if config.interface.unified_bus.write_mask %}
        ,.wem_n({DATA_WIDTH{1'b0}})  // TODO: Map write mask from pads if needed
{% endif %}
    );

endmodule

`default_nettype wire
